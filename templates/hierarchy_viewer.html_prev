<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Hierarchy Viewer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #3498db;
      --primary-dark: #2980b9;
      --text-color: #333;
      --light-gray: #f5f5f5;
      --medium-gray: #e0e0e0;
      --dark-gray: #95a5a6;
      --error-color: #e74c3c;
      --success-color: #2ecc71;
      --warning-color: #f39c12;
      --border-radius: 4px;
      --box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --focus-ring: 0 0 0 2px rgba(52, 152, 219, 0.5);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: #f9f9f9;
      padding: 20px;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(300px, 1fr) 400px;
      grid-template-rows: auto 1fr auto;
      gap: 20px;
      height: calc(100vh - 40px);
    }

    /* Header Styles */
    header {
      grid-column: 1 / -1;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 15px;
      padding: 10px 0;
      border-bottom: 1px solid var(--medium-gray);
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--primary-color);
    }

    .search-container {
      display: flex;
      gap: 10px;
      align-items: center;
      width: 100%;
      max-width: 500px;
      flex: 1 1 auto;
    }

    .search-box {
      flex: 1;
      position: relative;
      min-width: 200px;
    }

    .search-input {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid var(--medium-gray);
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: var(--focus-ring);
    }

    .search-actions {
      display: flex;
      gap: 5px;
    }

    .btn {
      padding: 10px 15px;
      border: none;
      border-radius: var(--border-radius);
      background-color: var(--primary-color);
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .btn:hover {
      background-color: var(--primary-dark);
    }

    .btn:focus {
      outline: none;
      box-shadow: var(--focus-ring);
    }

    .btn--icon {
      padding: 10px;
    }

    .btn--outline {
      background-color: transparent;
      border: 1px solid var(--medium-gray);
      color: var(--text-color);
    }

    .btn--outline:hover {
      background-color: var(--light-gray);
    }

    .search-count {
      background-color: var(--light-gray);
      padding: 10px;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      min-width: 80px;
      text-align: center;
    }

    .search-count.has-results {
      background-color: var(--primary-color);
      color: white;
    }

    /* Tree Container Styles */
    .tree-container {
      grid-column: 1;
      grid-row: 2;
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0; /* Fix for Firefox flexbox overflow */
    }

    .tree-header {
      padding: 15px;
      border-bottom: 1px solid var(--medium-gray);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tree-title {
      font-weight: bold;
      font-size: 1.1rem;
    }

    .tree-actions {
      display: flex;
      gap: 10px;
    }

    #tree {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      position: relative;
    }

    .tree__item {
      margin-left: 20px;
      position: relative;
    }

    .tree__item.open > .tree__children {
      display: block;
    }

    .tree__row {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 8px 10px;
      border-radius: var(--border-radius);
      cursor: pointer;
      margin-bottom: 2px;
    }

    .tree__row:hover {
      background-color: var(--light-gray);
    }

    .tree__row[aria-selected="true"] {
      background-color: rgba(52, 152, 219, 0.1);
      outline: 2px solid var(--primary-color);
    }

    .tree__row:focus {
      outline: none;
      box-shadow: var(--focus-ring);
    }

    .tree__expander {
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--dark-gray);
      transition: var(--transition);
    }

    .tree__expander:hover {
      color: var(--primary-color);
    }

    .tree__expander:focus {
      outline: none;
      box-shadow: var(--focus-ring);
    }

    .tree__expander .fa-caret-right {
      transition: transform 0.2s ease;
    }

    .tree__item.open > .tree__row > .tree__expander .fa-caret-right {
      transform: rotate(90deg);
    }

    .tree__label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree__children {
      display: none;
      margin-left: 15px;
      border-left: 1px dashed var(--medium-gray);
      padding-left: 10px;
    }

    /* Search Highlighting */
    .search-hit {
      background-color: rgba(255, 255, 0, 0.2);
    }

    .search-hit--active {
      animation: highlight 1s;
    }

    @keyframes highlight {
      0% { background-color: rgba(255, 255, 0, 0.5); }
      100% { background-color: rgba(255, 255, 0, 0.2); }
    }

    /* Details Panel Styles */
    .details-container {
      grid-column: 2;
      grid-row: 2;
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .details-header {
      padding: 15px;
      border-bottom: 1px solid var(--medium-gray);
    }

    .details-title {
      font-weight: bold;
      font-size: 1.1rem;
    }

    #details {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    /* Node Header Styles */
    .node-header {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 20px;
    }

    .node-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2rem;
      flex-shrink: 0;
    }

    .node-info {
      flex: 1;
      min-width: 0;
    }

    .node-name {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 5px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .node-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      font-size: 0.9rem;
      color: var(--dark-gray);
    }

    .node-meta-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    /* Tab Styles */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--medium-gray);
      margin-bottom: 15px;
    }

    .tab {
      padding: 10px 15px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 0.9rem;
      position: relative;
      top: 1px;
      background: none;
      border: none;
      color: inherit;
    }

    .tab:hover {
      color: var(--primary-color);
    }

    .tab:focus {
      outline: none;
      box-shadow: var(--focus-ring);
    }

    .tab--active {
      border-bottom-color: var(--primary-color);
      color: var(--primary-color);
      font-weight: bold;
    }

    /* Panel Styles */
    .panel {
      display: none;
      margin-bottom: 20px;
    }

    .panel--active {
      display: block;
    }

    .panel-title {
      font-size: 1rem;
      margin-bottom: 10px;
      color: var(--dark-gray);
      font-weight: bold;
    }

    /* Table Styles */
    .attributes-table {
      width: 100%;
      border-collapse: collapse;
    }

    .attributes-table th {
      text-align: left;
      padding: 8px;
      background-color: var(--light-gray);
      font-weight: normal;
      font-size: 0.9rem;
    }

    .attributes-table td {
      padding: 8px;
      border-bottom: 1px solid var(--medium-gray);
      font-family: monospace;
      font-size: 0.9rem;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .empty-row {
      color: var(--dark-gray);
      font-style: italic;
    }

    /* Relationship List Styles */
    .relation-list {
      list-style: none;
    }

    .relation-link {
      background: none;
      border: none;
      color: var(--primary-color);
      cursor: pointer;
      padding: 5px 0;
      text-align: left;
      width: 100%;
      text-align: left;
    }

    .relation-link:hover {
      text-decoration: underline;
    }

    .relation-link:focus {
      outline: none;
      text-decoration: underline;
    }

    /* JSON Viewer Styles */
    .json-viewer {
      background-color: var(--light-gray);
      padding: 15px;
      border-radius: var(--border-radius);
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 0.85rem;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Status Bar Styles */
    .status-bar {
      grid-column: 1 / -1;
      grid-row: 3;
      padding: 10px;
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      font-size: 0.9rem;
      color: var(--dark-gray);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* Loading States */
    .loading-state {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 10;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(52, 152, 219, 0.2);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    .empty-state {
      text-align: center;
      padding: 20px;
      color: var(--dark-gray);
    }

    .error-state {
      text-align: center;
      padding: 20px;
      color: var(--error-color);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Responsive Adjustments */
    @media (max-width: 1024px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto auto;
        height: auto;
        min-height: 100vh;
      }

      .tree-container {
        grid-column: 1;
        grid-row: 2;
      }

      .details-container {
        grid-column: 1;
        grid-row: 3;
      }

      .status-bar {
        grid-row: 4;
      }
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: stretch;
      }

      .search-container {
        max-width: 100%;
      }

      .node-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .node-meta {
        flex-direction: column;
        gap: 5px;
      }
    }
  </style>
</head>
<body data-root-name="{{ root_name }}" data-diagram-name="{{ diagram_name }}">
  <div id="load-error" style="display:none; color: #f87171; background: #1f2937; padding: 1rem; border: 1px solid #b91c1c; font-family: monospace;"></div>
  <div class="container">
    <header>
      <div class="logo">Hierarchy Viewer</div>
      <div class="search-container">
        <div class="search-box">
          <input type="text" id="search-input" class="search-input" placeholder="Search nodes..." aria-label="Search nodes">
        </div>
        <div class="search-actions">
          <button id="search-run" class="btn btn--icon" title="Search" aria-label="Search">
            <i class="fas fa-search" aria-hidden="true"></i>
          </button>
          <button id="search-clear" class="btn btn--icon btn--outline" title="Clear" aria-label="Clear search">
            <i class="fas fa-times" aria-hidden="true"></i>
          </button>
          <div id="search-count" class="search-count" aria-live="polite">0 / 0</div>
        </div>
      </div>
    </header>

    <div class="tree-container">
      <div class="tree-header">
        <div class="tree-title">Hierarchy Tree</div>
        <div class="tree-actions">
          <button id="expand-all" class="btn btn--outline btn--icon" title="Expand All" aria-label="Expand all nodes">
            <i class="fas fa-plus-square" aria-hidden="true"></i>
          </button>
          <button id="collapse-all" class="btn btn--outline btn--icon" title="Collapse All" aria-label="Collapse all nodes">
            <i class="fas fa-minus-square" aria-hidden="true"></i>
          </button>
        </div>
      </div>
      <div id="tree" role="tree" aria-label="Hierarchy tree" data-src="/api/hierarchy/{{ root_name }}/{{ diagram_name }}">
        <div class="loading-state">
          <div class="loading-spinner"></div>
          <p>Loading hierarchy data...</p>
        </div>
      </div>
    </div>

    <div class="details-container">
      <div class="details-header"><div class="details-title">Node Details</div></div>
      <div id="details" hidden aria-live="polite">
        <div class="loading-state">
          <div class="loading-spinner"></div>
          <p>Loading node details...</p>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <div><span id="node-count">0</span> nodes in hierarchy</div>
      <div>Last updated: <time id="last-updated">—</time></div>
    </div>
  </div>

  <script>
    /**
     * Advanced Hierarchy Viewer – Interactive tree visualization with keyboard navigation, 
     * search, and details panel
     * @module hierarchy_viewer
     * @version 2.0.0
     * @license MIT
     */

    // Utility functions for DOM manipulation
    const $ = (selector, context = document) => context.querySelector(selector);
    const $$ = (selector, context = document) => Array.from(context.querySelectorAll(selector));

    /**
     * @typedef {Object} TreeNode
     * @property {string} id - Unique identifier for the node
     * @property {string} name - Display name of the node
     * @property {number} level - Depth level in the hierarchy
     * @property {HTMLElement} element - DOM element for the node
     * @property {any} data - Original data object
     * @property {string} path - Full path in the hierarchy
     * @property {string} initials - Initials for avatar display
     * @property {boolean} hasChildren - Whether the node has children
     */

    class SearchManager {
      constructor(viewer) {
        this.viewer = viewer;
        this.searchInput = $('#search-input');
        this.searchCount = $('#search-count');
        this.searchRun = $('#search-run');
        this.searchClear = $('#search-clear');
        this.matches = [];
        this.allNodes = [];
        this.currentIndex = -1;
        this.lastQuery = '';
        this.debounceTimer = null;
        this.debounceDelay = 300;

        this._initialize();
      }

      _initialize() {
        if (!this.searchInput || !this.searchCount) {
          console.warn('SearchManager: Required elements not found');
          return;
        }

        this._setupEventListeners();
      }

      _setupEventListeners() {
        this.searchRun?.addEventListener('click', () => this.executeSearch());
        this.searchClear?.addEventListener('click', () => this.clearSearch());
        
        this.searchInput?.addEventListener('input', () => {
          this._debounceSearch();
        });
        
        this.searchInput?.addEventListener('keydown', (event) => {
          switch (event.key) {
            case 'Enter':
              this.executeSearch();
              if (this.currentIndex >= 0) this.navigateToMatch(this.currentIndex);
              break;
            case 'ArrowDown':
              event.preventDefault();
              this.moveToNextMatch();
              break;
            case 'ArrowUp':
              event.preventDefault();
              this.moveToPreviousMatch();
              break;
            case 'Escape':
              this.clearSearch();
              break;
          }
        });
      }

      _debounceSearch() {
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => {
          this.executeSearch();
          if (this.currentIndex >= 0) this.navigateToMatch(this.currentIndex);
        }, this.debounceDelay);
      }

      /**
       * Build the search index from flattened nodes
       * @param {TreeNode[]} nodes - Array of flattened nodes
       */
      buildIndex(nodes) {
        this.allNodes = nodes;
      }

      /**
       * Execute the search with current query
       */
      executeSearch() {
        const query = (this.searchInput?.value ?? '').trim().toLowerCase();
        if (!query) return this.clearSearch();

        this.lastQuery = query;
        this.matches = this.allNodes.filter(node => {
          const nameMatch = node.name.toLowerCase().includes(query);
          const pathMatch = node.path.toLowerCase().includes(query);
          return nameMatch || pathMatch;
        });

        this.currentIndex = this.matches.length > 0 ? 0 : -1;
        this._updateSearchUI();
        this._highlightMatches();
        
        if (this.currentIndex >= 0) {
          this.navigateToMatch(this.currentIndex);
        }
      }

      moveToNextMatch() {
        if (this.matches.length === 0) return;
        this.currentIndex = (this.currentIndex + 1) % this.matches.length;
        this._updateSearchUI();
        this.navigateToMatch(this.currentIndex);
      }

      moveToPreviousMatch() {
        if (this.matches.length === 0) return;
        this.currentIndex = (this.currentIndex - 1 + this.matches.length) % this.matches.length;
        this._updateSearchUI();
        this.navigateToMatch(this.currentIndex);
      }

      /**
       * Navigate to a specific match by index
       * @param {number} index - Index of the match to navigate to
       */
      navigateToMatch(index) {
        const node = this.matches[index];
        if (node?.element) {
          this.viewer.focusNode(node.element, true);
          
          // Add temporary active class for visual feedback
          node.element.classList.add('search-hit--active');
          setTimeout(() => {
            node.element.classList.remove('search-hit--active');
          }, 1000);
        }
      }

      clearSearch() {
        this.matches = [];
        this.currentIndex = -1;
        this.lastQuery = '';
        
        if (this.searchInput) {
          this.searchInput.value = '';
          this.searchInput.focus();
        }
        
        this._updateSearchUI();
        this._clearHighlights();
      }

      _updateSearchUI() {
        if (this.searchCount) {
          const hasResults = this.matches.length > 0;
          this.searchCount.textContent = `${this.currentIndex >= 0 ? this.currentIndex + 1 : 0} / ${this.matches.length}`;
          this.searchCount.classList.toggle('has-results', hasResults);
        }
      }

      _clearHighlights() {
        // Remove all search highlighting
        $$('.search-hit').forEach(element => {
          element.classList.remove('search-hit', 'search-hit--active');
          
          const label = element.querySelector('.tree__label');
          if (label && label.dataset.originalText) {
            label.textContent = label.dataset.originalText;
          }
        });
      }

      _highlightMatches() {
        // First clear any existing highlights
        this._clearHighlights();

        // Highlight new matches
        this.matches.forEach(match => {
          match.element.classList.add('search-hit');
          
          const label = match.element.querySelector('.tree__label');
          if (label) {
            // Store original text if we haven't already
            if (!label.dataset.originalText) {
              label.dataset.originalText = label.textContent;
            }
            
            // Highlight matching text
            const safeQuery = this.lastQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${safeQuery})`, 'ig');
            label.innerHTML = label.dataset.originalText.replace(regex, '<mark>$1</mark>');
          }
        });
      }
    }

    class DetailsPanel {
      constructor(viewer) {
        this.viewer = viewer;
        this.panelElement = $('#details');
        this.detailsContent = $('#details > .panel-content');
        
        if (!this.panelElement) {
          console.warn('DetailsPanel: Main panel element not found');
          return;
        }

        // Create template for panel content
        this._createPanelTemplate();
        
        // Initialize tabs
        this._initializeTabs();
      }

      _createPanelTemplate() {
        const template = `
          <div class="node-header">
            <div id="node-avatar" class="node-avatar" aria-hidden="true"></div>
            <div class="node-info">
              <div id="node-name" class="node-name"></div>
              <div class="node-meta">
                <div class="node-meta-item"><i class="fas fa-tag" aria-hidden="true"></i><span id="node-type"></span></div>
                <div class="node-meta-item"><i class="fas fa-layer-group" aria-hidden="true"></i><span id="node-depth"></span></div>
                <div class="node-meta-item"><i class="fas fa-link" aria-hidden="true"></i><span id="node-children"></span></div>
              </div>
            </div>
          </div>

          <div class="tabs" role="tablist">
            <button class="tab tab--active" data-tab="attributes" role="tab" aria-selected="true" tabindex="0" aria-controls="panel-attributes">
              <i class="fas fa-list-ul" aria-hidden="true"></i> Attributes
            </button>
            <button class="tab" data-tab="relationships" role="tab" aria-selected="false" tabindex="-1" aria-controls="panel-relationships">
              <i class="fas fa-project-diagram" aria-hidden="true"></i> Relationships
            </button>
            <button class="tab" data-tab="json" role="tab" aria-selected="false" tabindex="-1" aria-controls="panel-json">
              <i class="fas fa-code" aria-hidden="true"></i> JSON
            </button>
          </div>

          <div id="panel-attributes" class="panel panel--active" role="tabpanel" aria-labelledby="tab-attributes">
            <div class="panel-title">Node Attributes</div>
            <table class="attributes-table"><tbody id="attr-body"></tbody></table>
          </div>

          <div id="panel-relationships" class="panel" role="tabpanel" aria-labelledby="tab-relationships" hidden>
            <div class="panel-title">Node Relationships</div>
            <ul class="relation-list" id="rel-list"></ul>
          </div>

          <div id="panel-json" class="panel" role="tabpanel" aria-labelledby="tab-json" hidden>
            <div class="panel-title">Raw JSON Data</div>
            <pre class="json-viewer" id="json-block"></pre>
          </div>
        `;

        // Remove loading state if present
        const loadingState = this.panelElement.querySelector('.loading-state');
        if (loadingState) loadingState.remove();

        // Create container for panel content
        const contentContainer = document.createElement('div');
        contentContainer.className = 'panel-content';
        contentContainer.innerHTML = template;
        this.panelElement.appendChild(contentContainer);

        // Cache references to elements
        this.avatarElement = $('#node-avatar');
        this.nameElement = $('#node-name');
        this.typeElement = $('#node-type');
        this.depthElement = $('#node-depth');
        this.childrenCountElement = $('#node-children');
        this.attributesTable = $('#attr-body');
        this.relationshipsList = $('#rel-list');
        this.jsonViewer = $('#json-block');
      }

      _initializeTabs() {
        const tabs = $$('.tab', this.panelElement);
        if (tabs.length === 0) return;

        tabs.forEach(tab => {
          tab.addEventListener('click', () => this._activateTab(tab));
          tab.addEventListener('keydown', event => {
            if (['Enter', ' '].includes(event.key)) {
              event.preventDefault();
              this._activateTab(tab);
            }
          });
        });

        // Activate the first tab by default
        if (tabs.length > 0) {
          this._activateTab(tabs[0]);
        }
      }

      _activateTab(tab) {
        const tabId = tab.dataset.tab;
        if (!tabId) return;

        // Update tab states
        $$('.tab', this.panelElement).forEach(t => {
          const isActive = t === tab;
          t.classList.toggle('tab--active', isActive);
          t.setAttribute('aria-selected', isActive.toString());
          t.tabIndex = isActive ? 0 : -1;
        });

        // Update panel visibility
        $$('.panel', this.panelElement).forEach(panel => {
          const isActive = panel.id === `panel-${tabId}`;
          panel.hidden = !isActive;
          panel.classList.toggle('panel--active', isActive);
        });
      }

      /**
       * Render node details in the panel
       * @param {TreeNode} node - The node to display
       * @param {string} parentName - Name of the parent node
       */
      render(node, parentName = '—') {
        if (!this.panelElement) return;

        // Show the panel if hidden
        this.panelElement.hidden = false;

        // Basic node information
        this._renderBasicInfo(node, parentName);
        
        // Attributes table
        this._renderAttributes(node);
        
        // Relationships list
        this._renderRelationships(node);
        
        // JSON viewer
        this._renderJsonData(node);
      }

      _renderBasicInfo(node, parentName) {
        if (this.avatarElement) {
          this.avatarElement.textContent = node.initials || '—';
        }
        
        if (this.nameElement) {
          this.nameElement.textContent = node.name || '(unnamed)';
          this.nameElement.setAttribute('aria-label', `Node: ${node.name || 'unnamed node'}`);
        }
        
        if (this.typeElement) {
          this.typeElement.textContent = node.data.type || '—';
        }
        
        if (this.depthElement) {
          this.depthElement.textContent = node.level;
        }
        
        if (this.childrenCountElement) {
          this.childrenCountElement.textContent = node.hasChildren ? (node.data.children?.length || 0) : 0;
        }
      }

      _renderAttributes(node) {
        if (!this.attributesTable) return;

        const attributes = Object.entries(node.data)
          .filter(([key]) => !['id', 'name', 'type', 'children'].includes(key))
          .map(([key, value]) => {
            let displayValue;
            
            if (value === null || value === undefined) {
              displayValue = 'null';
            } else if (typeof value === 'object') {
              displayValue = JSON.stringify(value, null, 2);
            } else {
              displayValue = String(value);
            }
            
            return `
              <tr>
                <th scope="row">${key}</th>
                <td>${displayValue}</td>
              </tr>
            `;
          });

        this.attributesTable.innerHTML = attributes.length > 0
          ? attributes.join('')
          : '<tr class="empty-row"><td colspan="2"><i class="fas fa-info-circle" aria-hidden="true"></i> No attributes</td></tr>';
      }

      _renderRelationships(node) {
        if (!this.relationshipsList) return;

        const relationships = node.data.children?.map(child => {
          const childId = child.id || child.RuleGUID || '';
          return `
            <li>
              <button class="relation-link" data-id="${childId}" aria-label="Navigate to ${child.name || 'unnamed node'}">
                ${child.name || '(unnamed)'}
              </button>
            </li>
          `;
        }) || [];

        this.relationshipsList.innerHTML = relationships.length > 0
          ? relationships.join('')
          : '<li class="empty-row"><i class="fas fa-link-slash" aria-hidden="true"></i> No relationships</li>';

        // Add click handlers to relationship links
        $$('.relation-link', this.relationshipsList).forEach(link => {
          link.addEventListener('click', () => {
            const nodeId = link.dataset.id;
            if (nodeId) {
              this.viewer.focusNodeById(nodeId, true);
            }
          });
        });
      }

      _renderJsonData(node) {
        if (!this.jsonViewer) return;

        try {
          this.jsonViewer.textContent = JSON.stringify(node.data, (key, value) => {
            // Handle circular references
            if (typeof value === 'object' && value !== null) {
              return value;
            }
            return value;
          }, 2);
        } catch (error) {
          console.error('Failed to stringify node data:', error);
          this.jsonViewer.textContent = 'Unable to display JSON data';
        }
      }
    }

    class HierarchyViewer {
      constructor() {
        this.treeContainer = $('#tree');
        
        if (!this.treeContainer) {
          console.error('HierarchyViewer: Tree container element not found');
          return;
        }

        this.flatNodes = [];
        this.visitedNodeIds = new Set();
        this.detailsPanel = new DetailsPanel(this);
        this.searchManager = new SearchManager(this);
        this.isLoading = false;

        this._initialize();
      }

      _initialize() {
        // Set up expand/collapse all buttons
        $('#expand-all')?.addEventListener('click', () => this._expandAllNodes());
        $('#collapse-all')?.addEventListener('click', () => this._collapseAllNodes());

        // Initialize when DOM is ready
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          setTimeout(() => this.loadHierarchyData(), 0);
        } else {
          document.addEventListener('DOMContentLoaded', () => this.loadHierarchyData());
        }
      }

      async loadHierarchyData() {
        try {
          this._showLoadingState();
          
          const dataSource = this.treeContainer.dataset.src;
          if (!dataSource) {
            throw new Error('Missing data source URL in data-src attribute');
          }

          const response = await fetch(dataSource);
          if (!response.ok) {
            throw new Error(`Failed to load data: HTTP ${response.status}`);
          }

          const jsonData = await response.json();
          const rules = jsonData?.data?.rules;
          
          if (!Array.isArray(rules)) {
            throw new Error('Invalid data format: expected rules array');
          }

          const treeStructure = this._buildTreeFromFlatList(rules);
          if (treeStructure.length === 0) {
            return this._showEmptyState();
          }

          this._flattenTree(treeStructure);
          this._renderTree();
          this.searchManager.buildIndex(this.flatNodes);
          this._setupTreeEventHandlers();
          this._updateStatusBar();

          // Handle initial hash navigation if present
          this._handleInitialHashNavigation();
        } catch (error) {
          console.error('[HierarchyViewer] Error loading data:', error);
          this._showErrorState(error.message);
        } finally {
  <div id="load-error" style="display: block !important; color: #f87171; background: #1f2937; padding: 1rem; border: 1px solid #b91c1c; font-family: monospace; z-index: 9999;">
    [diagnostic placeholder — if you see this, JS fetch error may not be triggering]
  </div>
        }
      }

      _buildTreeFromFlatList(flatRules) {
        const nodeMap = new Map();
        const rootNodes = [];

        // First pass: create all nodes
        flatRules.forEach((rule, index) => {
          const id = rule.RuleGUID || `node-${index}`;
          nodeMap.set(index, { ...rule, id, children: [] });
        });

        // Second pass: build hierarchy
        flatRules.forEach((rule, index) => {
          const parentIndex = rule.ParentActionIndex;
          const currentNode = nodeMap.get(index);
          
          if (typeof parentIndex === 'number' && nodeMap.has(parentIndex)) {
            nodeMap.get(parentIndex).children.push(currentNode);
          } else {
            rootNodes.push(currentNode);
          }
        });

        return rootNodes;
      }

  _flattenTree(nodes, level = 0, path = []) {
  this.flatNodes = [];
  
  const flatten = (nodes, level, path) => {
    return nodes.flatMap(node => {
      const nodePath = [...path, node.name || node.id];
      const pathString = nodePath.join(' > ');
      
      const treeNode = {
        id: node.id || node.RuleGUID,
        name: node.name || node.RuleName || '(unnamed)',
        level,
        path: pathString,
        data: node,
        hasChildren: node.children && node.children.length > 0,
        initials: this._getInitials(node.name || node.RuleName || '')
      };
      
      const result = [treeNode];
      
      if (node.children && node.children.length > 0) {
        result.push(...flatten(node.children, level + 1, nodePath));
      }
      
      return result;
    });
  };
  
  this.flatNodes = flatten(nodes, level, path);
}

_getInitials(name) {
  if (!name) return '—';
  
  // Handle special cases
  if (name.length <= 2) return name.toUpperCase();
  
  // Get first letters of first two words
  const words = name.split(/\s+/);
  if (words.length >= 2) {
    return (words[0].charAt(0) + words[1].charAt(0)).toUpperCase();
  }
  
  // For single word names, take first two characters
  return name.substring(0, 2).toUpperCase();
}

_renderTree() {
  if (!this.treeContainer) return;
  
  // Clear existing content
  this.treeContainer.innerHTML = '';
  
  // Build the tree from flattened nodes
  const rootNodes = this.flatNodes.filter(node => node.level === 0);
  
  if (rootNodes.length === 0) {
    return this._showEmptyState();
  }
  
  const treeElement = document.createElement('div');
  treeElement.className = 'tree__root';
  
  rootNodes.forEach(node => {
    treeElement.appendChild(this._createTreeNodeElement(node));
  });
  
  this.treeContainer.appendChild(treeElement);
}

_createTreeNodeElement(node) {
  const itemElement = document.createElement('div');
  itemElement.className = 'tree__item';
  itemElement.dataset.nodeId = node.id;
  
  const rowElement = document.createElement('div');
  rowElement.className = 'tree__row';
  rowElement.tabIndex = -1;
  rowElement.setAttribute('role', 'treeitem');
  rowElement.setAttribute('aria-expanded', 'false');
  rowElement.setAttribute('aria-level', node.level + 1);
  rowElement.setAttribute('aria-selected', 'false');
  
  if (node.hasChildren) {
    const expander = document.createElement('button');
    expander.className = 'tree__expander';
    expander.innerHTML = '<i class="fas fa-caret-right" aria-hidden="true"></i>';
    expander.setAttribute('aria-label', 'Expand');
    expander.addEventListener('click', (e) => {
      e.stopPropagation();
      this._toggleNode(itemElement);
    });
    rowElement.appendChild(expander);
  } else {
    // Add spacer for nodes without children
    const spacer = document.createElement('span');
    spacer.className = 'tree__expander';
    spacer.style.visibility = 'hidden';
    rowElement.appendChild(spacer);
  }
  
  const labelElement = document.createElement('span');
  labelElement.className = 'tree__label';
  labelElement.textContent = node.name;
  rowElement.appendChild(labelElement);
  
  // Store reference to node data
  rowElement._nodeData = node;
  node.element = rowElement;
  
  rowElement.addEventListener('click', (e) => {
    e.stopPropagation();
    this._selectNode(rowElement);
  });
  
  rowElement.addEventListener('keydown', (e) => {
    this._handleKeyNavigation(e, rowElement);
  });
  
  itemElement.appendChild(rowElement);
  
  if (node.hasChildren) {
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'tree__children';
    childrenContainer.setAttribute('role', 'group');
    itemElement.appendChild(childrenContainer);
    
    // Add loading indicator for children
    if (node.data.children && node.data.children.length > 0) {
      this._renderChildNodes(node, childrenContainer);
    }
  }
  
  return itemElement;
}

_renderChildNodes(parentNode, containerElement) {
  const children = this.flatNodes.filter(node => 
    node.data.ParentActionIndex === parentNode.data.ActionIndex
  );
  
  if (children.length === 0) return;
  
  children.forEach(childNode => {
    const childElement = this._createTreeNodeElement(childNode);
    containerElement.appendChild(childElement);
  });
}

_toggleNode(itemElement) {
  const isOpen = itemElement.classList.contains('open');
  const rowElement = itemElement.querySelector('.tree__row');
  
  if (isOpen) {
    itemElement.classList.remove('open');
    rowElement.setAttribute('aria-expanded', 'false');
  } else {
    itemElement.classList.add('open');
    rowElement.setAttribute('aria-expanded', 'true');
    
    // If children haven't been loaded yet, load them
    const childrenContainer = itemElement.querySelector('.tree__children');
    if (childrenContainer && childrenContainer.children.length === 0) {
      const nodeData = rowElement._nodeData;
      if (nodeData?.data?.children) {
        this._renderChildNodes(nodeData, childrenContainer);
      }
    }
  }
}

_selectNode(rowElement) {
  // Deselect all nodes
  $$('.tree__row[aria-selected="true"]').forEach(el => {
    el.setAttribute('aria-selected', 'false');
    el.classList.remove('selected');
  });
  
  // Select clicked node
  rowElement.setAttribute('aria-selected', 'true');
  rowElement.classList.add('selected');
  
  // Focus the row
  rowElement.focus();
  
  // Show details in panel
  const nodeData = rowElement._nodeData;
  if (nodeData) {
    this.detailsPanel.render(nodeData);
    
    // Update URL hash for deep linking
    window.location.hash = `#node-${nodeData.id}`;
    
    // Mark as visited
    this.visitedNodeIds.add(nodeData.id);
  }
}

_handleKeyNavigation(event, rowElement) {
  const nodeData = rowElement._nodeData;
  if (!nodeData) return;
  
  const itemElement = rowElement.closest('.tree__item');
  if (!itemElement) return;
  
  switch (event.key) {
    case 'Enter':
    case ' ':
      event.preventDefault();
      this._selectNode(rowElement);
      if (nodeData.hasChildren) {
        this._toggleNode(itemElement);
      }
      break;
      
    case 'ArrowRight':
      if (nodeData.hasChildren) {
        if (!itemElement.classList.contains('open')) {
          this._toggleNode(itemElement);
        } else {
          // Move focus to first child
          const firstChildRow = itemElement.querySelector('.tree__children .tree__row');
          if (firstChildRow) firstChildRow.focus();
        }
      }
      break;
      
    case 'ArrowLeft':
      if (itemElement.classList.contains('open')) {
        this._toggleNode(itemElement);
      } else {
        // Move focus to parent
        const parentItem = itemElement.parentElement.closest('.tree__item');
        if (parentItem) {
          parentItem.querySelector('.tree__row').focus();
        }
      }
      break;
      
    case 'ArrowUp':
      event.preventDefault();
      this._navigateVertically(rowElement, -1);
      break;
      
    case 'ArrowDown':
      event.preventDefault();
      this._navigateVertically(rowElement, 1);
      break;
      
    case 'Home':
      event.preventDefault();
      const firstRow = this.treeContainer.querySelector('.tree__row');
      if (firstRow) firstRow.focus();
      break;
      
    case 'End':
      event.preventDefault();
      const rows = $$('.tree__row', this.treeContainer);
      if (rows.length > 0) rows[rows.length - 1].focus();
      break;
  }
}

_navigateVertically(currentRow, direction) {
  const allRows = $$('.tree__row', this.treeContainer);
  const currentIndex = allRows.indexOf(currentRow);
  
  if (currentIndex >= 0) {
    const targetIndex = currentIndex + direction;
    if (targetIndex >= 0 && targetIndex < allRows.length) {
      allRows[targetIndex].focus();
    }
  }
}

_expandAllNodes() {
  $$('.tree__item').forEach(item => {
    item.classList.add('open');
    const row = item.querySelector('.tree__row');
    if (row) row.setAttribute('aria-expanded', 'true');
  });
}

_collapseAllNodes() {
  $$('.tree__item').forEach(item => {
    item.classList.remove('open');
    const row = item.querySelector('.tree__row');
    if (row) row.setAttribute('aria-expanded', 'false');
  });
}

focusNode(element, scrollIntoView = true) {
  if (!element) return;
  
  this._selectNode(element);
  if (scrollIntoView) {
    element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

focusNodeById(nodeId, scrollIntoView = true) {
  const rowElement = $(`[data-node-id="${nodeId}"] .tree__row`);
  if (rowElement) {
    this.focusNode(rowElement, scrollIntoView);
    
    // Ensure all ancestors are expanded
    let parentItem = rowElement.closest('.tree__item');
    while (parentItem) {
      parentItem.classList.add('open');
      const parentRow = parentItem.querySelector('.tree__row');
      if (parentRow) parentRow.setAttribute('aria-expanded', 'true');
      parentItem = parentItem.parentElement.closest('.tree__item');
    }
  }
}

_handleInitialHashNavigation() {
  if (window.location.hash) {
    const nodeId = window.location.hash.replace('#node-', '');
    if (nodeId) {
      setTimeout(() => {
        this.focusNodeById(nodeId, true);
      }, 100);
    }
  }
}

_updateStatusBar() {
  const nodeCount = this.flatNodes.length;
  $('#node-count').textContent = nodeCount.toLocaleString();
  
  const now = new Date();
  $('#last-updated').textContent = now.toLocaleTimeString();
  $('#last-updated').dateTime = now.toISOString();
}

_showLoadingState() {
  if (!this.treeContainer) return;
  
  this.isLoading = true;
  this.treeContainer.innerHTML = `
    <div class="loading-state">
      <div class="loading-spinner"></div>
      <p>Loading hierarchy data...</p>
    </div>
  `;
}

_hideLoadingState() {
  this.isLoading = false;
}

_showEmptyState() {
  if (!this.treeContainer) return;
  
  this.treeContainer.innerHTML = `
    <div class="empty-state">
      <i class="fas fa-tree" aria-hidden="true"></i>
      <p>No hierarchy data available</p>
    </div>
  `;
}

_showErrorState(message) {
  if (!this.treeContainer) return;
  
  this.treeContainer.innerHTML = `
    <div class="error-state">
      <i class="fas fa-exclamation-triangle" aria-hidden="true"></i>
      <p>Failed to load hierarchy data</p>
      <p class="error-message">${message}</p>
    </div>
  `;
}
}

// Initialize the viewer when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new HierarchyViewer();
});